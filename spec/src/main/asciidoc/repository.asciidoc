
= Repository

In DDD, the repository pattern encapsulates the logic required to access data sources. They consolidate data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.

image::01-repository.png[alt=repository structure, width=70%, height=70%]

This pattern focuses on the closest proximity of entities and hides where the data comes from, making it possible for a Repository to use a DAO pattern.

The Repository pattern is a well-documented way of working with a data source. In the book https://www.amazon.com/dp/0321127420/[Patterns of Enterprise Application] Architecture, Martin Fowler describes a repository as follows:

> A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory. Client objects declaratively build queries and send them to the repositories for answers. Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer. Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.

It also becomes very famous in https://www.amazon.com/dp/0321125215/[Domain-Driven Design: Tackling Complexity in the Heart of Software] by Eric Evans.

== Repositories on Jakarta Data

A repository abstraction aims to significantly reduce the boilerplate code required to implement data access layers for various persistence stores.

The parent interface in Jakarta Data repository abstraction is DataRepository.

By default, Jakarta Data has support for three interfaces. However, the core is extensible. Therefore, a provider might extend one or more interfaces to a specific data target as th

image::02-repositories.png[alt=Repositories types]

* Interface to generic CRUD operations on a repository for a specific type. This one we can see more often on several Java implementations.
* Interface with generic CRUD operations using the pagination feature.
* Interface for generic CRUD operations on a repository for a specific type. This repository follows reactive paradigms.

From the Java developer perspective, create an interface that extends one of those interfaces besides the Repository annotation.

So, given a ```Product``` entity where the ID is a ```long``` type, the repository would be:

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

}
----


=== Query methods

On Jakarta Data, besides finding by an ID, it provides custom queries on two modes:

Through Query annotation: It will create a method annotated with the @Query with the query.
Using method by query convention: Using some pattern vocabulary will provide a query.

